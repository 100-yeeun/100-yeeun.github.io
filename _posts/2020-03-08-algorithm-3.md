---

layout: article
category: algorithm
title: "프로그래머스: 카펫"
tags: algorithm
image: 
        teaser: main.jpg
---

#### 문제 



Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 빨간색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.

![image.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/7c94563a35/2ff27ac9-97d0-43a9-9cf8-a344b8e7912e.png)

Leo는 집으로 돌아와서 아까 본 카펫의 빨간색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.

Leo가 본 카펫에서 갈색 격자의 수 brown, 빨간색 격자의 수 red가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.





#### 제한사항



- 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
- 빨간색 격자의 수 red는 1 이상 2,000,000 이하인 자연수입니다.
- 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.





#### 정답 코드

```c++
#include <string>
#include <vector>

using namespace std;

vector<int> solution(int brown, int red) {
    vector<int> answer;

    //레드가 1인 경우, 브라운이 바깥 한 줄 이라는 문제 조건에 따라 답은 하나다.
    if(red == 1){
        answer.push_back(3);
        answer.push_back(3);

        return answer;
    }

    /*
        레드가 1인 경우를 분리해서 for문의 조건문(red/2)에 오류가 없다.
    */
    for(int i=1; i<=(int)red/2; i++){

        //red를 i로 나눴을 때 딱 나눠떨어지는 i를 세로
        //(가로보다 세로가 짧다는 조건 + i=1 부터 시작하는 작은수)
        if (red%i == 0){
            //카펫 실제 크기는 red 바깥을 brown이 한줄씩 감싸기 때문에 red의 가로세로 크기에 +2
            int width = (red/i) + 2;
            int height = i + 2;

            //가로세로 격자수를 곱한 카펫크기가 brown 과 red 타일의 합과 같다면 답 출력
            if(width * height == brown + red){
                answer.push_back(width);
                answer.push_back(height);

                return answer;
            }
        }
    }
    return answer;
}
```







#### 느낀점

완전탐색 문제 부류에 들어있는데.. 완전탐색이 뭐인지도 잘 기억이 안난다... 과제하기에 급급해 문제만 풀지말고 하나하나 차근차근 정리해보자...






#### 참고

- [프로그래머스: 카펫](https://programmers.co.kr/learn/courses/30/lessons/42842)